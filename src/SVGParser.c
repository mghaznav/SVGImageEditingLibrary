/*************************\
*  Muhammad Ali Ghaznavi  *
*  mghaznav@uoguelph.ca   *
*        1068753          *
*      13/03/2020         *
\*************************/

#include <string.h>
#include <ctype.h>
#include <math.h>
#include <unistd.h>
#include <stdbool.h>
#include <stdlib.h>
#include "SVGParser.h"

#define M_PI 3.1415926535897932

void setObjects(SVGimage * img, xmlNode * root);
void setAttributes(SVGimage * img, xmlNode * rootElement);
void setGroupAttributes(Group * group, xmlNode * rootElement);

Attribute * createAttribute(xmlAttr * attr);
Rectangle * createRectangle(xmlNode * currNode);
Circle * createCircles(xmlNode * currNode);
Path * createPath(xmlNode * currNode);
Group * createGroup(xmlNode * node);

void getRectsFromGroups(Group * group, List * rects);
void getCircsFromGroups(Group * group, List * circ);
void getGroupsFromGroups(Group * group, List * groups);
void getPathsFromGroups(Group * group, List * paths);

int getRectsNumAttr(List * list);
int getCircleNumAttr(List * list);
int getPathsNumAttr(List * list);
int getGroupNumAttr(List * list);

void deleteNothing(void * data);
void freeListWithoutData(List * list);

bool validateXMLTree(xmlDoc * doc, char * schemaFile);
bool validateSVGimage(SVGimage* image, char* schemaFile);
bool validateImage(SVGimage * image);
bool validateRects(List * rects);
bool validateAttributes(List * attributes);
bool validateCircles(List * circles);
bool validatePaths(List * paths);
bool validateGroups(List * groups);

void addAttributesToNode(xmlNode * node, List * attributes);
void addRectanglesToNode(xmlNode * node, List * rects);
void addCirclesToNode(xmlNode * node, List * circles);
void addPathsToNode(xmlNode * node, List * paths);
void addGroupsToNode(xmlNode * node, List * groups);

void updateOtherAttr(List * attributes, Attribute * newAttribute);
void updateCircle(List * circles, int index, Attribute * newAttribute);
void updateRect(List * rects, int index, Attribute * newAttribute);
void updatePath(List * paths, int index, Attribute * newAttribute);
void updateGroup(List * groups, int index, Attribute * newAttribute);

void * getItemAtIndex(List * list, int index);

xmlDoc * svgImageToXmlDoc(SVGimage * img);

char * getValueFromJSONstring(char * name, const char * JSONstring);

int numDigits(int num);

/** Function to create an SVG object based on the contents of an SVG file.
 *@pre File name cannot be an empty string or NULL. File represented by this name must exist and must be readable.
 *@post Either: A valid SVGimage has been created and its address was returned or An error occurred, and NULL was returned
 *@return the pinter to the new struct or NULL
 *@param fileName - a string containing the name of the SVG file
**/
SVGimage* createSVGimage(char* fileName)
{
    SVGimage * newImg;
    xmlDoc * doc;
    xmlNode * rootElement;
    xmlNs * nameSpace;

    //Validates file name.
    if(fileName == NULL)
    {
        return NULL;
    }
    else if(strlen(fileName) <= 0)
    {
        return NULL;
    }

    LIBXML_TEST_VERSION

    if(access(fileName, F_OK) == -1)
    {
        return NULL;
    }

    //Opens the file and gets the root element
    doc = xmlReadFile(fileName, NULL, 0);
    
    if(doc == NULL)
    {
        return NULL;
    }

    rootElement = xmlDocGetRootElement(doc);

    //Gets the name space
    if(rootElement->ns != NULL)
    {
        newImg = malloc(sizeof(SVGimage));
        nameSpace = rootElement->ns;
        strcpy(newImg->namespace, (char *)nameSpace->href);
    }
    else
    {
        return NULL;
    }

    setObjects(newImg, rootElement);
    setAttributes(newImg, rootElement);
    xmlFreeDoc(doc);
    xmlCleanupParser();

    return newImg;
}

/** Function to create an SVG object based on the contents of an SVG file.
 * This function must validate the XML tree generated by libxml against a SVG schema file
 * before attempting to traverse the tree and create an SVGimage struct
 *@pre File name cannot be an empty string or NULL. File represented by this name must exist and 
 * must be readable. Schema file name is not NULL/empty, and represents a valid schema file
 *@post Either: A valid SVGimage has been created and its address was returned or 
 * An error occurred, or SVG file was invalid, and NULL was returned
 *@return the pinter to the new struct or NULL
 *@param fileName - a string containing the name of the SVG file
 *@param schemaFile - a string containing the name of the xsd file
**/
SVGimage* createValidSVGimage(char * fileName, char * schemaFile)
{
    SVGimage * img;
    xmlDoc * doc;

    //Validates fileName and schemsFile.
    if(fileName == NULL || schemaFile == NULL)
    {
        return NULL;
    }
    else if(strlen(fileName) <= 0 || strlen(schemaFile) <= 0 )
    {
        return NULL;
    }

    if(access(fileName, F_OK) == -1)
    {
        printf("Could Not Open File\n");
        return NULL;
    }

    if(access(schemaFile, F_OK) == -1)
    {
        printf("Could Not Open Schema File\n");
        return NULL;
    }

    doc = xmlReadFile(fileName, NULL, 0);

    if(!validateXMLTree(doc, schemaFile))
    {
        return NULL;
    }
    
    xmlFreeDoc(doc);

    /* Creates the image */
    img = createSVGimage(fileName);

    return img;

}

/** Function to writing a SVGimage into a file in SVG format.
 *@pre SVGimage object exists, is valid, and and is not NULL. fileName is not NULL, has the correct extension
 *@post SVGimage has not been modified in any way, and a file representing the SVGimage contents in SVG format has been created
 *@return a boolean value indicating success or failure of the write
 *@param image - a pointer to a SVGimage struct
 *@param fileName - the name of the output file
 **/
bool writeSVGimage(SVGimage * image, char * fileName)
{
    xmlDoc * doc;

    if(image == NULL || fileName == NULL)
    {
        return false;
    }

    /* Creating xml tree */
    doc = svgImageToXmlDoc(image);

    if(doc == NULL)
    {
        return false;
    }

    /* Write the doc to file */
    if(xmlSaveFormatFileEnc(fileName, doc, "UTF-8", 1) == -1)
    {
        return false;
    }

    /* Freeing memory */
    xmlFreeDoc(doc);
    xmlCleanupParser();

    return true;
}

/** Function to validating an existing a SVGimage object against a SVG schema file
 *@pre SVGimage object exists and is not NULL schema file name is not NULL/empty, and represents a valid schema file
 *@post SVGimage has not been modified in any way
 *@return the boolean aud indicating whether the SVGimage is valid
 *@param image - a pointer to a GPXSVGimagedoc struct
 *@param schemaFile - the name of a schema file
**/
bool validateSVGimage(SVGimage* image, char* schemaFile)
{
    xmlDoc * img;

    /* Validating arguments */
    if(image == NULL || schemaFile == NULL)
    {
        return NULL;
    }

    if(access(schemaFile, F_OK) == -1)
    {
        return NULL;
    }

    /* Creating xml Tree */
    img = svgImageToXmlDoc(image);

    if(img == NULL)
    {
        return false;
    }

    /* Validating xml tree using the schema */
    if(!validateXMLTree(img, schemaFile))
    {
        xmlFreeDoc(img);
        return false;
    }

    xmlFreeDoc(img);

    if(!validateImage(image))
    {
        return false;
    }

    return true;

}

/** Function to validating an existing a SVGimage according to SVGParser.h
 *@return the boolean aud indicating whether the SVGimage is valid
 *@param image - a pointer to a GPXSVGimagedoc struct
**/
bool validateImage(SVGimage * image)
{
    if(image == NULL)
    {
        return false;
    }

    if(!validateAttributes(image->otherAttributes))
    {
        return false;
    }

    if(!validateRects(image->rectangles))
    {
        return false;
    }

    if(!validateCircles(image->circles))
    {
        return false;
    }

    if(!validatePaths(image->paths))
    {
        return false;
    }

    if(!validateGroups(image->groups))
    {
        return false;
    }

    return true;
}

/** Function to validating a List of rectangles according to SVGParser.h
 *@return the boolean aud indicating whether the rectangles are valid
 *@param rects - a pointer to the List of rectangles
**/
bool validateRects(List * rects)
{
    Rectangle * currRect;
    Node * node;

    if(rects == NULL)
    {
        return false;
    }

    if(rects->length == 0)
    {
        return true;
    }

    node = rects->head;

    while(node != NULL)
    {
        if(node->data == NULL)
        {
            return false;
        }

        currRect = (Rectangle *) node->data;

        /* Validate the rectangle */
        if(currRect->width < 0.0f || currRect->height < 0.0f || currRect->otherAttributes == NULL)
        {
            return false;
        }

        if(!validateAttributes(currRect->otherAttributes))
        {
            return false;
        }

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    return true;

}

/** Function to validating a List of circles according to SVGParser.h
 *@return the boolean aud indicating whether the circles are valid
 *@param circles - a pointer to the List of circles
**/
bool validateCircles(List * circles)
{
    Circle * currCirc;
    Node * node;

    if(circles == NULL)
    {
        return false;
    }

    if(circles->length == 0)
    {
        return true;
    }

    node = circles->head;

    while(node != NULL)
    {
        if(node->data == NULL)
        {
            return false;
        }

        currCirc = (Circle *) node->data;

        /* Validate the Circle */
        if(currCirc->r < 0.0f || currCirc->otherAttributes == NULL)
        {
            return false;
        }

        if(!validateAttributes(currCirc->otherAttributes))
        {
            return false;
        }

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    return true;
}

/** Function to validating a List of paths according to SVGParser.h
 *@return the boolean aud indicating whether the paths are valid
 *@param paths - a pointer to the List of paths
**/
bool validatePaths(List * paths)
{
    Path * currPath;
    Node * node;

    if(paths == NULL)
    {
        return false;
    }

    if(paths->length == 0)
    {
        return true;
    }

    node = paths->head;

    while(node != NULL)
    {
        if(node->data == NULL)
        {
            return false;
        }

        currPath = (Path *) node->data;

        /* Validate the Path */
        if(currPath->data == NULL || currPath->otherAttributes == NULL)
        {
            return false;
        }

        if(!validateAttributes(currPath->otherAttributes))
        {
            return false;
        }

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    return true;
}

/** Function to validating a List of groups according to SVGParser.h
 *@return the boolean aud indicating whether the groups are valid
 *@param groups - a pointer to the List of groups
**/
bool validateGroups(List * groups)
{
    Group * currGroup;
    Node * node;

    if(groups == NULL)
    {
        return false;
    }

    if(groups->length == 0)
    {
        return true;
    }

    node = groups->head;

    while(node != NULL)
    {
        if(node->data == NULL)
        {
            return false;
        }

        currGroup = (Group *) node->data;

        /* Validate the Group */
        if(!validateRects(currGroup->rectangles))
        {
            return false;
        }

        if(!validateCircles(currGroup->circles))
        {
            return false;
        }

        if(!validatePaths(currGroup->paths))
        {
            return false;
        }

        if(!validateGroups(currGroup->groups))
        {
            return false;
        }

        if(!validateAttributes(currGroup->otherAttributes))
        {
            return false;
        }

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    return true;
}

/** Function to validating a List of attributes according to SVGParser.h
 *@return the boolean aud indicating whether the attributes are valid
 *@param attributes - a pointer to the List of attributes
**/
bool validateAttributes(List * attributes)
{
    Attribute * currAttr;
    Node * node;

    if(attributes == NULL)
    {
        return false;
    }

    if(attributes->length == 0)
    {
        return true;
    }

    node = attributes->head;

    while(node != NULL)
    {
        if(node->data == NULL)
        {
            return false;
        }

        currAttr = (Attribute *) node->data;

        /* Validate the attribute */
        if(currAttr->name == NULL || currAttr->value == NULL)
        {
            return false;
        }

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    return true;
}

/** Function to convert and SVGimage struct to an xmlTree
 *@return the xmlDoc with the xmlTree
 *@param img - a pointer to the SVGimage to convert to an xmlTree
**/
xmlDoc * svgImageToXmlDoc(SVGimage * img)
{
    xmlDoc * doc;
    xmlNode * root;
    xmlNs * nameSpace;

    if(img == NULL)
    {
        return NULL;
    }

    /* Creating the new tree and setting the name space */
    doc = xmlNewDoc((xmlChar *) "1.0");
    root = xmlNewNode(NULL, (xmlChar *) "svg");
    nameSpace = xmlNewNs(root, (xmlChar *) img->namespace, NULL);
    xmlDocSetRootElement(doc, root);
    xmlSetNs(root, nameSpace);
    addAttributesToNode(root, img->otherAttributes);

    /* Adding description */
    if(strcmp(img->title, "empty") != 0)
    {
        xmlNewChild(root, NULL, (xmlChar *) "title", (xmlChar *) img->title);
    }

    /* Adding title */
    if(strcmp(img->description, "empty") != 0)
    {
        xmlNewChild(root, NULL, (xmlChar *) "desc", (xmlChar *) img->description);
    }

    /* Adding top level shapes */
    addRectanglesToNode(root, img->rectangles);
    addCirclesToNode(root, img->circles);
    addPathsToNode(root, img->paths);
    addGroupsToNode(root, img->groups);

    return doc;

}

/** Function to add rectangles to an xmlNode
 *@param node - a pointer to the xmlNode to add the rectangles to
 *@param rects - a pointer to the List of rectangles to add to the xmlNode
**/
void addRectanglesToNode(xmlNode * node, List * rects)
{
    Node * rect;
    Rectangle * currRect;
    xmlNode * currNode;
    char buffer[128];

    if(node == NULL || rects == NULL || rects->length == 0)
    {
        return;
    }

    rect = rects->head;

    while(true)
    {
        if(rect->data == NULL)
        {
            break;
        }

        currRect = (Rectangle *) rect->data;
        currNode = xmlNewChild(node, NULL, (xmlChar *) "rect", NULL);
        
        /* Adding x coordinate */
        snprintf(buffer, 128, "%f", currRect->x);
        strcat(buffer, currRect->units);
        xmlNewProp(currNode, (xmlChar *) "x", (xmlChar *) buffer);

        /* Adding y coordinate */
        snprintf(buffer, 128, "%f", currRect->y);
        strcat(buffer, currRect->units);
        xmlNewProp(currNode, (xmlChar *) "y", (xmlChar *) buffer);

        /* Adding width */
        snprintf(buffer, 128, "%f", currRect->width);
        strcat(buffer, currRect->units);
        xmlNewProp(currNode, (xmlChar *) "width", (xmlChar *) buffer);

        /* Adding height */
        snprintf(buffer, 128, "%f", currRect->height);
        strcat(buffer, currRect->units);
        xmlNewProp(currNode, (xmlChar *) "height", (xmlChar *) buffer);
        
        /* Adding other attributes */
        addAttributesToNode(currNode, currRect->otherAttributes);

        if(rect->next == NULL)
        {
            break;
        }
        else
        {
            rect = rect->next;
        }
    }
}

/** Function to add circles to an xmlNode
 *@param node - a pointer to the xmlNode to add the circles to
 *@param circles - a pointer to the List of circles to add to the xmlNode
**/
void addCirclesToNode(xmlNode * node, List * circles)
{
    Node * circle;
    Circle * currCirc;
    xmlNode * currNode;
    char buffer[128];

    if(node == NULL || circles == NULL || circles->length == 0)
    {
        return;
    }

    circle = circles->head;

    while(true)
    {
        if(circle->data == NULL)
        {
            break;
        }

        currCirc = (Circle *) circle->data;
        currNode = xmlNewChild(node, NULL, (xmlChar *) "circle", NULL);
        
        /* Adding cx */
        snprintf(buffer, 128, "%f", currCirc->cx);
        strcat(buffer, currCirc->units);
        xmlNewProp(currNode, (xmlChar *) "cx", (xmlChar *) buffer);

        /* Adding cy */
        snprintf(buffer, 128, "%f", currCirc->cy);
        strcat(buffer, currCirc->units);
        xmlNewProp(currNode, (xmlChar *) "cy", (xmlChar *) buffer);

        /* Adding r */
        snprintf(buffer, 128, "%f", currCirc->r);
        strcat(buffer, currCirc->units);
        xmlNewProp(currNode, (xmlChar *) "r", (xmlChar *) buffer);
        
        /* Adding other attributes */
        addAttributesToNode(currNode, currCirc->otherAttributes);

        if(circle->next == NULL)
        {
            break;
        }
        else
        {
            circle = circle->next;
        }
    }
}

/** Function to add paths to an xmlNode
 *@param node - a pointer to the xmlNode to add the paths to
 *@param paths - a pointer to the List of paths to add to the xmlNode
**/
void addPathsToNode(xmlNode * node, List * paths)
{
    Node * path;
    Path * currPath;
    xmlNode * currNode;

    if(node == NULL || paths == NULL || paths->length == 0)
    {
        return;
    }

    path = paths->head;

    while(true)
    {
        if(path->data == NULL)
        {
            break;
        }

        currPath = (Path *) path->data;
        currNode = xmlNewChild(node, NULL, (xmlChar *) "path", NULL);
        
        /* Adding other attributes */
        addAttributesToNode(currNode, currPath->otherAttributes);
        
        /* Adding data */
        xmlNewProp(currNode, (xmlChar *) "d", (xmlChar *) currPath->data);

        if(path->next == NULL)
        {
            break;
        }
        else
        {
            path = path->next;
        }
    }
}

/** Function to add groups to an xmlNode
 *@param node - a pointer to the xmlNode to add the groups to
 *@param groups - a pointer to the List of groups to add to the xmlNode
**/
void addGroupsToNode(xmlNode * node, List * groups)
{
    Node * group;
    Group * currGroup;
    xmlNode * currNode;

    if(node == NULL || groups == NULL || groups->length == 0)
    {
        return;
    }

    group = groups->head;

    while(true)
    {
        if(group->data == NULL)
        {
            break;
        }

        currGroup = (Group *) group->data;
        currNode = xmlNewChild(node, NULL, (xmlChar *) "g", NULL);
        
        /* Adding other attributes */
        addAttributesToNode(currNode, currGroup->otherAttributes);

        /* Adding shapes*/
        addRectanglesToNode(currNode, currGroup->rectangles);
        addCirclesToNode(currNode, currGroup->circles);
        addPathsToNode(currNode, currGroup->paths);
        addGroupsToNode(currNode, currGroup->groups);

        if(group->next == NULL)
        {
            break;
        }
        else
        {
            group = group->next;
        }
    }
}

/** Function to add attributes to an xmlNode
 *@param node - a pointer to the xmlNode to add the attributes to
 *@param attributes - a pointer to the List of attributes to add to the xmlNode
**/
void addAttributesToNode(xmlNode * node, List * attributes)
{
    Node * attr;
    Attribute * currAttr;

    if(node == NULL || attributes == NULL || attributes->length == 0)
    {
        return;
    }

    attr = attributes->head;

    while(true)
    {
        if(attr->data == NULL)
        {
            break;
        }

        currAttr = (Attribute *) attr->data;
        xmlNewProp(node, (xmlChar *) currAttr->name, (xmlChar *) currAttr->value);

        if(attr->next == NULL)
        {
            break;
        }
        else
        {
            attr = attr->next;
        }
    }

}

/** Function to create a string representation of an SVG object.
 *@pre SVGimgage exists, is not null, and is valid
 *@post SVGimgage has not been modified in any way, and a string representing the SVG contents has been created
 *@return a string contaning a humanly readable representation of an SVG object
 *@param obj - a pointer to an SVG struct
**/
char* SVGimageToString(SVGimage* img)
{
    char * desc;
    char * attributes;
    char * rects;
    char * circ;
    char * path;
    char * groups;
    int len;
    int extraChars = 5;

    if(img == NULL)
    {
        return NULL;
    }

    //Calculate amount of chars needed other than the string len's
    extraChars = (img->title[0] != '0') ? extraChars + 8 : extraChars;
    extraChars = (img->description[0] != '0') ? extraChars + 14 : extraChars;

    //Get Objects strings
    attributes = toString(img->otherAttributes);
    rects = toString(img->rectangles);
    circ = toString(img->circles);
    path = toString(img->paths);
    groups = toString(img->groups);

    //Calculate string len for all the elements needed
    len = strlen(img->namespace);
    len = (img->title[0] != '0') ? len + strlen(img->title) : len;
    len = (img->description[0] != '0') ? len + strlen(img->description) : len;
    len += strlen(rects);
    len += strlen(attributes);
    len += strlen(circ);
    len += strlen(path);
    len += strlen(groups);

    //Allocating memory
    desc = malloc((sizeof(char) * (len + extraChars)));

    //Creating the description string
    strcpy(desc, "NS: ");
    strcat(desc, img->namespace);
    
    if(img->title[0] != '0')
    {
        strcat(desc, "\nTitle: ");
        strcat(desc, img->title);
    }

    if(img->description[0] != '0')
    {
        strcat(desc, "\nDescription: ");
        strcat(desc, img->description);
    }

    strcat(desc, attributes);
    strcat(desc, rects);
    strcat(desc, circ);
    strcat(desc, path);
    strcat(desc, groups);

    desc[len + extraChars - 1] = '\0';

    //Freeing the attribute string
    free(attributes);
    free(rects);
    free(circ);
    free(path);
    free(groups);

    return desc;
}

/** Function to delete image content and free all the memory.
 *@pre SVGimgage  exists, is not null, and has not been freed
 *@post SVSVGimgageG  had been freed
 *@return none
 *@param obj - a pointer to an SVG struct
**/
void deleteSVGimage(SVGimage* img)
{
    if(img != NULL)
    {
        freeList(img->rectangles);
        freeList(img->circles);
        freeList(img->paths);
        freeList(img->groups);
        freeList(img->otherAttributes);
        free(img);
    }
}

/** Function that returns a list of all rectangles in the image. 
 *@pre SVGimgage exists, is not null, and has not been freed
 *@post SVGimgage has not been modified in any way
 *@return a newly allocated List of components.
**/
List* getRects(SVGimage* img)
{
    List * rects = initializeList(rectangleToString, deleteNothing, compareRectangles);
    
    if(img == NULL)
    {
        return rects;
    }

    Node * currNode = img->rectangles->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(rects, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = img->groups->head;

    while(currNode != NULL)
    {
        getRectsFromGroups((Group *)currNode->data, rects);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return rects;
}

/** Function that returns a list of all circles in the image. 
 *@pre SVGimgage exists, is not null, and has not been freed
 *@post SVGimgage has not been modified in any way
 *@return a newly allocated List of components.
**/
List* getCircles(SVGimage* img)
{
    List * circ = initializeList(circleToString, deleteNothing, compareCircles);
    
    if(img == NULL)
    {
        return circ;
    }

    Node * currNode = img->circles->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(circ, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = img->groups->head;

    while(currNode != NULL)
    {
        getCircsFromGroups((Group *)currNode->data, circ);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return circ;
}

/** Function that returns a list of all groups in the image. 
 *@pre SVGimgage exists, is not null, and has not been freed
 *@post SVGimgage has not been modified in any way
 *@return a newly allocated List of components.
**/
List* getGroups(SVGimage* img)
{
    List * groups = initializeList(groupToString, deleteNothing, compareGroups);
    
    if(img == NULL)
    {
        return groups;
    }

    Node * currNode = img->groups->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(groups, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = img->groups->head;

    while(currNode != NULL)
    {
        getGroupsFromGroups((Group *)currNode->data, groups);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return groups;
}

/** Function that returns a list of all paths in the image. 
 *@pre SVGimgage exists, is not null, and has not been freed
 *@post SVGimgage has not been modified in any way
 *@return a newly allocated List of components.
**/
List* getPaths(SVGimage* img)
{
    List * paths = initializeList(pathToString, deleteNothing, comparePaths);
    
    if(img == NULL)
    {
        return paths;
    }

    Node * currNode = img->paths->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(paths, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = img->groups->head;

    while(currNode != NULL)
    {
        getPathsFromGroups((Group *)currNode->data, paths);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return paths;
}

/** Function that returns the number of all rectangles with the specified area
 *@pre SVGimgage exists, is not null, and has not been freed.  The search criterion is valid
 *@post SVGimgage has not been modified in any way
 *@return an int indicating how many objects matching the criterion are contained in the image
 *@param obj - a pointer to an SVG struct
 *@param 2nd - the second param depends on the function.  See details below
**/   
int numRectsWithArea(SVGimage* img, float area)
{
    float calculatedArea;
    int numRects = 0;

    if(img == NULL || area < 0)
    {
        return 0;
    }

    List * rects = getRects(img);
    Node * currNode = rects->head;

    while(currNode != NULL)
    {
        Rectangle * currRect = (Rectangle *)currNode->data;

        calculatedArea = ceil(currRect->width * currRect->height);

        if(ceil(calculatedArea) == ceil(area))
        {
            numRects++;
        }
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    freeList(rects);

    return numRects;
}

/** Function that returns the number of all circles with the specified area
 *@pre SVGimgage exists, is not null, and has not been freed.  The search criterion is valid
 *@post SVGimgage has not been modified in any way
 *@return an int indicating how many objects matching the criterion are contained in the image
 *@param obj - a pointer to an SVG struct
 *@param 2nd - the second param depends on the function.  See details below
**/ 
int numCirclesWithArea(SVGimage* img, float area)
{
    float calculatedArea;
    int numCircs = 0;

    if(img == NULL || area < 0)
    {
        return 0;
    }

    List * circs = getCircles(img);
    Node * currNode = circs->head;

    while(currNode != NULL)
    {
        Circle * currCirc = (Circle *)currNode->data;

        calculatedArea = (currCirc->r * currCirc->r) * M_PI;

        if(ceil(calculatedArea) == ceil(area))
        {
            numCircs++;
        }
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    freeList(circs);

    return numCircs;
}

/** Function that returns the number of all paths with the specified data
 *@pre SVGimgage exists, is not null, and has not been freed.  The search criterion is valid
 *@post SVGimgage has not been modified in any way
 *@return an int indicating how many objects matching the criterion are contained in the image
 *@param obj - a pointer to an SVG struct
 *@param 2nd - the second param depends on the function.  See details below
**/ 
int numPathsWithdata(SVGimage* img, char* data)
{
    int numPaths = 0;

    if(img == NULL || data == NULL)
    {
        return 0;
    }

    List * paths = getPaths(img);
    Node * currNode = paths->head;

    while(currNode != NULL)
    {
        Path * currPath = (Path *)currNode->data;

        if(strcmp(currPath->data, data) == 0)
        {
            numPaths++;
        }
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    freeList(paths);

    return numPaths;
}

/** Function that returns the number of all groups with the specified length
 *@pre SVGimgage exists, is not null, and has not been freed.  The search criterion is valid
 *@post SVGimgage has not been modified in any way
 *@return an int indicating how many objects matching the criterion are contained in the image
 *@param obj - a pointer to an SVG struct
 *@param 2nd - the second param depends on the function.  See details below
**/ 
int numGroupsWithLen(SVGimage* img, int len)
{
    int currLen;
    int numGroups = 0;

    if(img == NULL || len < 0)
    {
        return 0;
    }

    List * groups = getGroups(img);
    Node * currNode = groups->head;

    while(currNode != NULL)
    {
        Group * currGroup = (Group *)currNode->data;

        currLen = getLength(currGroup->rectangles)  + getLength(currGroup->circles) + getLength(currGroup->paths) + getLength(currGroup->groups);

        if(currLen == len)
        {
            numGroups++;
        }
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    freeList(groups);

    return numGroups;
}

/** Function that returns the total number of Attribute structs in the SVGimage - i.e. the number of Attributes
 * contained in all otherAttributes lists in the structs making up the SVGimage
 *@pre SVGimgage  exists, is not null, and has not been freed.  
 *@post SVGimage has not been modified in any way
 *@return the total length of all attribute structs in the SVGimage
 *@param obj - a pointer to an SVG struct
**/
int numAttr(SVGimage* img)
{
    int numAttr;

    if(img == NULL)
    {
        return 0;
    }

    List * rects = getRects(img);
    List * circs = getCircles(img);
    List * paths = getPaths(img);
    List * groups = getGroups(img);

    numAttr = getLength(img->otherAttributes) + getRectsNumAttr(rects) + getCircleNumAttr(circs) + getPathsNumAttr(paths) + getGroupNumAttr(groups); 

    freeList(rects);
    freeList(circs);
    freeList(paths);
    freeList(groups);

    return numAttr;
}

/** This function deletes an attribute passed to it
 * @param void - a pointer to the attribute struct
**/ 
void deleteAttribute( void* data)
{
    if(data == NULL)
    {
        return;
    }

    Attribute * attr = (Attribute *)data;
    free(attr->name);
    free(attr->value);
    free(attr);
}

/** This function converts an attribute to a string
 * @param void - A pointer to an attribute struct
**/
char* attributeToString( void* data)
{
    if(data == NULL)
    {
        return NULL;
    }

    char * desc;
    int len;
    Attribute * attr = (Attribute *)data;

    len = strlen(attr->name) + strlen(attr->value) + 31;

    desc = malloc(sizeof(char) * (len));

    strcpy(desc, "***Attribute***\nName: ");
    strcat(desc, attr->name);
    strcat(desc, "\nValue: ");
    strcat(desc, attr->value);

    return desc;
}

/** This is a dummy function as I am not using it anywhere in my code.
 * @return - The function always returns 0
**/
int compareAttributes(const void * first, const void * second)
{
    return 0;
}

/** This function compares the names of two attributes
 *@return true if the names match, false otherwise
 *@param first - the first attribute
 *@param second - the second attribute 
**/
bool compareAttributesBool(const void * first, const void * second)
{
    Attribute * attrOne = (Attribute *) first;
    Attribute * attrTwo = (Attribute *) second;

    if(strcmp(attrOne->name, attrTwo->name) == 0)
    {
        return true;
    }
    else
    {
        return false;
    }
}

/** This function deletes a group freeing all the memory properly.
 * @param void - A pointer to a Group struct.
**/
void deleteGroup(void* data)
{
    if(data == NULL)
    {
        return;
    }

    Group * group = (Group *)data;

    freeList(group->rectangles);
    freeList(group->circles);
    freeList(group->paths);
    freeList(group->otherAttributes);
    freeList(group->groups);
    free(group);
}

/** This function takes in a group and converts it in to a string.
 * @return - String representation of the group
 * @param void - A pointer to a Group struct
**/
char* groupToString( void* data)
{
    char * desc;
    char * rects;
    char * circ;
    char * path;
    char * groups;
    char * attr;
    int len;

    if(data == NULL)
    {
        return NULL;
    }

    Group * group = (Group *)data;

    attr = toString(group->otherAttributes);
    rects = toString(group->rectangles);
    circ = toString(group->circles);
    path = toString(group->paths);
    groups = toString(group->groups);

    len = strlen(attr) + strlen(rects) + strlen(circ) + strlen(path) + strlen(groups);

    desc = malloc(sizeof(char) * (len + 13));
    
    strcpy(desc, "***Group***\n");
    strcat(desc, rects);
    strcat(desc, circ);
    strcat(desc, path);
    strcat(desc, attr);
    strcat(desc, groups);

    free(rects);
    free(circ);
    free(path);
    free(groups);
    free(attr);

    return desc;
}

/** This is a dummy function as I am not using it anywhere in my code.
 * @return - The function always returns 0
**/
int compareGroups(const void *first, const void *second)
{
    return 0;
}

/** This function deletes a rectangle
 * @param void - A pointer to a Rectangle struct
**/
void deleteRectangle(void* data)
{
    if(data == NULL)
    {
        return;
    }

    Rectangle * rect = (Rectangle *)data;
    freeList(rect->otherAttributes);
    free(rect);
}

void deleteNothing(void* data)
{
    return;
}

/** This function takes in a rectangle and converts it in to a string.
 * @return - String representation of the rectangle
 * @param void - A pointer to a rectangle struct
**/
char* rectangleToString(void* data)
{
    char * desc;
    char * attrDesc;
    char buffer[500];
    int len;

    if(data == NULL)
    {
        return NULL;
    }

    Rectangle * rect = (Rectangle *)data;

    sprintf(buffer, "***Rectangle***\nX: %.2f\nY: %.2f\nWidth: %.2f\nHeight: %.2f\n", rect->x, rect->y, rect->width, rect->height);

    attrDesc = toString(rect->otherAttributes);

    len = strlen(buffer) + strlen(attrDesc) + 1; 

    desc = malloc(sizeof(char) * len);
    strcpy(desc, buffer);
    strcat(desc, attrDesc);

    free(attrDesc);

    return desc;
}

/** This is a dummy function as I am not using it anywhere in my code.
 * @return - The function always returns 0
**/
int compareRectangles(const void *first, const void *second)
{
    return 0;
}

/** This function deletes a Circle
 * @param void - A pointer to a Circle struct
**/
void deleteCircle(void* data)
{
    if(data == NULL)
    {
        return;
    }

    Circle * circ = (Circle *)data;
    freeList(circ->otherAttributes);
    free(circ);
}

/** This function takes in a circle and converts it in to a string.
 * @return - String representation of the circle
 * @param void - A pointer to a circle struct
**/
char* circleToString(void* data)
{    
    char * desc;
    char * attrDesc;
    char buffer[500];
    int len;

    if(data == NULL)
    {
        return NULL;
    }

    Circle * circ = (Circle *)data;

    sprintf(buffer, "***Circle***\nCX: %.2f\nCY: %.2f\nR: %.2f\n", circ->cx, circ->cy, circ->r);

    attrDesc = toString(circ->otherAttributes);

    len = strlen(buffer) + strlen(attrDesc) + 1; 

    desc = malloc(sizeof(char) * len);
    strcpy(desc, buffer);
    strcat(desc, attrDesc);

    free(attrDesc);

    return desc;
}

/** This is a dummy function as I am not using it anywhere in my code.
 * @return - The function always returns 0
**/
int compareCircles(const void *first, const void *second)
{
    return 0;
}

/** This function deletes a Path
 * @param void - A pointer to a Path struct
**/
void deletePath(void* data)
{
    if(data == NULL)
    {
        return;
    }

    Path * path = (Path *)data;
    free(path->data);
    freeList(path->otherAttributes);
    free(path);
}

/** This function takes in a path and converts it in to a string.
 * @return - String representation of the path
 * @param void - A pointer to a path struct
**/
char* pathToString(void* data)
{    
    char * desc;
    char * pathData;
    char * attrDesc;
    int len;

    if(data == NULL)
    {
        return NULL;
    }

    Path * path = (Path *)data;

    pathData = path->data;
    attrDesc = toString(path->otherAttributes);

    len = strlen(pathData) + strlen(attrDesc) + 18; 

    desc = malloc(sizeof(char) * len);
    strcpy(desc,"***Path***\nData: ");
    strcat(desc, pathData);
    strcat(desc, attrDesc);

    free(attrDesc);

    return desc;
}

/** This is a dummy function as I am not using it anywhere in my code.
 * @return - The function always returns 0
**/
int comparePaths(const void *first, const void *second)
{
    return 0;
}

/** This function sets the objects in the SVGimage struct using the xmlNode
 * @param SVGimage - A pointer to the image struct
 * @param xmlNode - Pointer to the root node of the SVG file
**/
void setObjects(SVGimage * img, xmlNode * root)
{
    xmlNode * currNode;
    int i;
  
    if(img == NULL || root == NULL)
    {
        return;
    }  

    List * rects = initializeList(rectangleToString, deleteRectangle, compareRectangles);
    List * circles = initializeList(circleToString, deleteCircle, compareCircles);
    List * paths = initializeList(pathToString, deletePath, comparePaths);
    List * groups = initializeList(groupToString, deleteGroup, compareGroups);

    if(root->children != NULL)
    {
        currNode = root->children;
        char name[100];

        strcpy(img->title, "empty");
        strcpy(img->description, "empty");

        while(true)
        {
            strcpy(name, (char *)currNode->name);
            for (i = 0; name[i] != '\0'; i++) 
            {
                name[i] = tolower(name[i]);
            }

            if(strcmp((char *)currNode->name, "rect") == 0)
            {
                insertBack(rects, createRectangle(currNode));
            }
            else if(strcmp((char *)currNode->name, "circle") == 0)
            {
                insertBack(circles, createCircles(currNode));
            }
            else if(strcmp((char *)currNode->name, "path") == 0)
            {
                insertBack(paths, createPath(currNode));
            }
            else if(strcmp((char *)currNode->name, "g") == 0)
            {
                insertBack(groups, createGroup(currNode));
            }
            else if(strcmp((char *)currNode->name, "title") == 0)
            {
                xmlNode * newNode = currNode->children;
                strncpy(img->title, (char *)newNode->content, 255);
            }
            else if(strcmp((char *)currNode->name, "desc") == 0)
            {
                xmlNode * newNode = currNode->children;
                strncpy(img->description, (char *)newNode->content, 255);
            }

            if(currNode->next == NULL)
            {
                break;
            }
            else
            {
                currNode = currNode->next;
            }
            
        }
    }

    img->rectangles = rects;
    img->circles = circles;
    img->paths = paths;
    img->groups = groups;
}

/** This function finds all the attributes in the root of the xml Tree and stores it in the SVGimage struct
 * @param SVGimage - A pointer to the image struct
 * @param xmlNode - A pointer to the root node of the xml tree
**/
void setAttributes(SVGimage * img, xmlNode * rootElement)
{
    List * attrList;
    xmlAttr * attr;

    if(img == NULL || rootElement == NULL)
    {
        return;
    }

    attrList = initializeList(attributeToString, deleteAttribute, compareAttributes);
    attr = rootElement->properties;

    while(true)
    {

        if(attr == NULL)
        {
            break;
        }

        Attribute * currAttr = createAttribute(attr);
        insertBack(attrList, currAttr);

        if(attr->next == NULL)
        {
            break;
        }
        else
        {
            attr = attr->next;
        }
    }

    img->otherAttributes = attrList;
}

/** This function takes an xmlAttr and converts it in to a Attribute struct
 * @return - The Attribute struct created
 * @param xmlAttr - The xmlAttr to be converted
**/
Attribute * createAttribute(xmlAttr * attr)
{
    if(attr == NULL)
    {
        return NULL;
    }

    Attribute * currAttr = malloc(sizeof(Attribute));
    xmlNode * value = attr->children;

    currAttr->name = malloc((sizeof(char) * strlen((char *)attr->name)) + 1);
    strcpy(currAttr->name, (char *)attr->name);

    currAttr->value = malloc((sizeof(char) * strlen((char *)value->content)) + 1);
    strcpy(currAttr->value, (char *)value->content);

    return currAttr;
}

/** This function takes an xmlNode and converts it in to a Rectangle struct
 * @return - The Rectangle struct created
 * @param xmlNode - The xmlNode to be converted
**/
Rectangle * createRectangle(xmlNode * currNode)
{
    char * units;
    int i;
    Rectangle * rect;
    List * otherAttr;
    xmlAttr * attr;
    xmlNode * value;

    //Initial pointer check
    if(currNode == NULL)
    {
        return NULL;
    }

    //Allocating memory and creating other attributes list
    rect = malloc(sizeof(Rectangle));
    otherAttr = initializeList(attributeToString, deleteAttribute, compareAttributes);
    rect->units[0] = 0;
    
    if(currNode->properties != NULL)
    {    
        attr = currNode->properties;

        i = 0;
        units = (char *)attr->children->content;

        //Getting units
        while(*units)
        {
            if((int)*units >= 65 && (int)*units <= 122)
            {
                rect->units[i] = *units;
                i++;
            }
            units++;
        }
        rect->units[i] = '\0';

        /* Initializing attributes */
        rect->x = 0.0;
        rect->y = 0.0;
        rect->height = 0.0;
        rect->width = 0.0;
        
        //Getting attributes
        while(true)
        {
            value = attr->children;

            if(strcmp((char *)attr->name, "x") == 0)
            {
                rect->x = atof((char *)value->content);
            }
            else if(strcmp((char *)attr->name, "y") == 0)
            {
                rect->y = atof((char *)value->content);
            }
            else if(strcmp((char *)attr->name, "width") == 0)
            {
                rect->width = atof((char *)value->content);
                if(rect->width <= 0.00)
                {
                    return NULL;
                }
            }
            else if(strcmp((char *)attr->name, "height") == 0)
            {
                rect->height = atof((char *)value->content);
                if(rect->height <= 0.00)
                {
                    return NULL;
                }
            }
            else
            {
                insertBack(otherAttr, createAttribute(attr));
            }

            //Break if all attributes stored
            if(attr->next == NULL)
            {
                break;
            }
            else
            {
                attr = attr->next;
            }
        }

        rect->otherAttributes = otherAttr;
    }
    else
    {
        return NULL;
    }

    return rect;
}

/** This function takes an xmlNode and converts it in to a Circle struct
 * @return - The Circle struct created
 * @param xmlNode - The xmlNode to be converted
**/
Circle * createCircles(xmlNode * currNode)
{
    char * units;
    int i;
    Circle * circ;
    List * otherAttr;
    xmlAttr * attr;
    xmlNode * value;

    //Initial pointer check
    if(currNode == NULL)
    {
        return NULL;
    }

    //Allocating memory and creating other attributes list
    circ = malloc(sizeof(Circle));
    otherAttr = initializeList(attributeToString, deleteAttribute, compareAttributes);
    circ->units[0] = 0;
    
    if(currNode->properties != NULL)
    {    
        attr = currNode->properties;

        i = 0;
        units = (char *)attr->children->content;

        //Getting units
        while(*units)
        {
            if((int)*units >= 65 && (int)*units <= 122)
            {
                circ->units[i] = *units;
                i++;
            }
            units++;
        }
        units[i] = '\0';

        /* Initialising attributes */
        circ->cx = 0.0;
        circ->cy = 0.0;
        circ->r = 0.0;
        
        //Getting attributes
        while(true)
        {
            value = attr->children;

            if(strcmp((char *)attr->name, "cx") == 0)
            {
                circ->cx = atof((char *)value->content);
            }
            else if(strcmp((char *)attr->name, "cy") == 0)
            {
                circ->cy = atof((char *)value->content);
            }
            else if(strcmp((char *)attr->name, "r") == 0)
            {
                circ->r = atof((char *)value->content);
                if(circ->r <= 0.00)
                {
                    return NULL;
                }
            }
            else
            {
                insertBack(otherAttr, createAttribute(attr));
            }

            //Break if all attributes stored
            if(attr->next == NULL)
            {
                break;
            }
            else
            {
                attr = attr->next;
            }
        }

        circ->otherAttributes = otherAttr;
    }
    else
    {
        return NULL;
    }

    return circ;
}

/** This function takes an xmlNode and converts it in to a Path struct
 * @return - The Path struct created
 * @param xmlNode - The xmlNode to be converted
**/
Path * createPath(xmlNode * currNode)
{
    Path * path;
    List * otherAttr;
    xmlAttr * attr;
    xmlNode * value;

    //Initial pointer check
    if(currNode == NULL)
    {
        return NULL;
    }

    //Allocating memory and creating other attributes list
    path = malloc(sizeof(Path));
    otherAttr = initializeList(attributeToString, deleteAttribute, compareAttributes);
    
    if(currNode->properties != NULL)
    {    
        attr = currNode->properties;
        
        //Getting attributes
        while(true)
        {
            value = attr->children;

            if(strcmp((char *)attr->name, "d") == 0)
            {
                path->data = malloc((sizeof(char) * strlen((char *)value->content)) + 1);
                strcpy(path->data, (char *)value->content);
            }
            else
            {
                insertBack(otherAttr, createAttribute(attr));
            }

            //Break if all attributes stored
            if(attr->next == NULL)
            {
                break;
            }
            else
            {
                attr = attr->next;
            }
        }

        path->otherAttributes = otherAttr;
    }
    else
    {
        return NULL;
    }

    return path;
}

/** This function takes an xmlNode and converts it in to a Group struct
 * @return - The Group struct created
 * @param xmlNode - The xmlNode to be converted
**/
Group * createGroup(xmlNode * node)
{
    int i;
    char name[100];

    if(node == NULL)
    {
        return NULL;
    }

    xmlNode * currNode = node->children;
    Group * group = malloc(sizeof(Group));
    List * rects = initializeList(rectangleToString, deleteRectangle, compareRectangles);
    List * circles = initializeList(circleToString, deleteCircle, compareCircles);
    List * paths = initializeList(pathToString, deletePath, comparePaths);
    List * groups = initializeList(groupToString, deleteGroup, compareGroups);

    while(true)
    {
        strcpy(name, (char *)currNode->name);
        for (i = 0; name[i] != '\0'; i++) 
        {
            name[i] = tolower(name[i]);
        }

        if(strcmp((char *)currNode->name, "rect") == 0)
        {
            insertBack(rects, createRectangle(currNode));
        }
        else if(strcmp((char *)currNode->name, "circle") == 0)
        {
            insertBack(circles, createCircles(currNode));
        }
        else if(strcmp((char *)currNode->name, "path") == 0)
        {
            insertBack(paths, createPath(currNode));
        }
        else if(strcmp((char *)currNode->name, "g") == 0)
        {
            insertBack(groups, createGroup(currNode));
        }

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
        
    }

    setGroupAttributes(group, node);
    group->rectangles = rects;
    group->circles = circles;
    group->paths = paths;
    group->groups = groups;

    return group;
}

/** This function gets all the attributes of a Group from it xmlNode
 * @param Group - A pointer to the group struct to store the attributes in
 * @param xmlNode - A pointer to the root of the group
**/
void setGroupAttributes(Group * group, xmlNode * rootElement)
{
    List * attrList;
    xmlAttr * attr;

    if(group == NULL || rootElement == NULL)
    {
        return;
    }

    attrList = initializeList(attributeToString, deleteAttribute, compareAttributes);
    attr = rootElement->properties;

    while(true)
    {
        if(attr == NULL)
        {
            break;
        }

        Attribute * currAttr = createAttribute(attr);
        insertBack(attrList, currAttr);

        if(attr->next == NULL)
        {
            break;
        }
        else
        {
            attr = attr->next;
        }
    }

    group->otherAttributes = attrList;
}

void getRectsFromGroups(Group * group, List * rects)
{
    if(group == NULL || rects == NULL)
    {
        return;
    }

    Node * currNode = group->rectangles->head;

    while(currNode != NULL)
    {
        insertBack(rects, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = group->groups->head;

    while(currNode != NULL)
    {
        getRectsFromGroups((Group *)currNode->data, rects);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }
}

/** This function gets all the circles in a Group
 * @param Group - A pointer to the Group to find the Circle in
 * @param List - A pointer to the list to store all the circles in
**/
void getCircsFromGroups(Group * group, List * circ)
{
    if(group == NULL || circ == NULL)
    {
        return;
    }

    Node * currNode = group->circles->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(circ, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = group->groups->head;

    while(currNode != NULL)
    {
        getCircsFromGroups((Group *)currNode->data, circ);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

}

/** This function gets all the groups in a Group
 * @param Group - A pointer to the Group to find the Group in
 * @param List - A pointer to the list to store all the groups in
**/
void getGroupsFromGroups(Group * group, List * groups)
{
    if(group == NULL || groups == NULL)
    {
        return;
    }

    Node * currNode = group->groups->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(groups, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = group->groups->head;

    while(currNode != NULL)
    {
        getGroupsFromGroups((Group *)currNode->data, groups);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }
}

/** This function gets all the paths in a Group
 * @param Group - A pointer to the Group to find the Path in
 * @param List - A pointer to the list to store all the paths in
**/
void getPathsFromGroups(Group * group, List * paths)
{
    if(group == NULL || paths == NULL)
    {
        return;
    }

    Node * currNode = group->paths->head;

    while(currNode != NULL)
    {
        //List data points to the same thing in memory
        insertBack(paths, currNode->data);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    currNode = group->groups->head;

    while(currNode != NULL)
    {
        getPathsFromGroups((Group *)currNode->data, paths);

        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }
}

/** This function frees a list without freeing the data inside of it.
 * @param List - A pointer to the list to be freed
**/
void freeListWithoutData(List * list)
{
    Node * currNode;
    Node * nextNode;

    if(list == NULL)
    {
        return;
    }
    else if (list->head == NULL)
    {
        return;
    }

    currNode = list->head;
    nextNode = currNode->next;

    while(currNode != NULL)
    {
        free(currNode);
        
        if(nextNode != NULL)
        {
            currNode = nextNode;
            nextNode = currNode->next;
        }
        else
        {
            break;
        }
    }

    free(list);
}

/** This function gets the total of all the attributes of all the rectangles in the list passed to it
 * @param - A pointer to the list of rectangles
**/
int getRectsNumAttr(List * list)
{
    int numAttr = 0;

    if(list == NULL)
    {
        return 0;
    }

    Node * currNode = list->head;

    while(currNode != NULL)
    {
        Rectangle * rect = (Rectangle *)currNode->data;
        numAttr += getLength(rect->otherAttributes);
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return numAttr;

}

/** This function gets the total of all the attributes of all the circles in the list passed to it
 * @param - A pointer to the list of circles
**/
int getCircleNumAttr(List * list)
{
    int numAttr = 0;

    if(list == NULL)
    {
        return 0;
    }

    Node * currNode = list->head;

    while(currNode != NULL)
    {
        Circle * circ = (Circle *)currNode->data;
        numAttr += getLength(circ->otherAttributes);
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return numAttr;

}

/** This function gets the total of all the attributes of all the paths in the list passed to it
 * @param - A pointer to the list of paths
**/
int getPathsNumAttr(List * list)
{
    int numAttr = 0;

    if(list == NULL)
    {
        return 0;
    }

    Node * currNode = list->head;

    while(currNode != NULL)
    {
        Path * path = (Path *)currNode->data;
        numAttr += getLength(path->otherAttributes);
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return numAttr;

}

/** This function gets the total of all the attributes of all the groups in the list passed to it
 * @param - A pointer to the list of groups
**/
int getGroupNumAttr(List * list)
{
    int numAttr = 0;

    if(list == NULL)
    {
        return 0;
    }

    Node * currNode = list->head;

    while(currNode != NULL)
    {
        Group * group = (Group *)currNode->data;
        numAttr += getLength(group->otherAttributes);
        
        if(currNode->next == NULL)
        {
            break;
        }
        else
        {
            currNode = currNode->next;
        }
    }

    return numAttr;

}

/** This function is a modified version of xmlvalidation.c from the address below:
 * http://knol2share.blogspot.com/2009/05/validate-xml-against-xsd-in-c.html 
 * This is the link provided in the A2 Module 1.
**/
bool validateXMLTree(xmlDoc * doc, char * schemaFile)
{
    xmlSchemaPtr schema = NULL;
    xmlSchemaParserCtxtPtr ctxt;

    ctxt = xmlSchemaNewParserCtxt(schemaFile);

    xmlSchemaSetParserErrors(ctxt, (xmlSchemaValidityErrorFunc) fprintf, (xmlSchemaValidityWarningFunc) fprintf, stderr);
    schema = xmlSchemaParse(ctxt);
    xmlSchemaFreeParserCtxt(ctxt);

    if (doc == NULL)
    {
        xmlSchemaCleanupTypes();
        xmlCleanupParser();

        return false;
    }
    else
    {
        xmlSchemaValidCtxtPtr ctxt;
        int ret;

        ctxt = xmlSchemaNewValidCtxt(schema);
        xmlSchemaSetValidErrors(ctxt, (xmlSchemaValidityErrorFunc) fprintf, (xmlSchemaValidityWarningFunc) fprintf, stderr);
        ret = xmlSchemaValidateDoc(ctxt, doc);
        
        if (ret != 0)
        {
            xmlSchemaFreeValidCtxt(ctxt);
            xmlSchemaCleanupTypes();
            xmlCleanupParser();

            return false;
        }

        xmlSchemaFreeValidCtxt(ctxt);
    }

    // free the resource
    if(schema != NULL)
    {
        xmlSchemaFree(schema);
    }

    xmlSchemaCleanupTypes();
    xmlCleanupParser();
    xmlMemoryDump();

    return true;

}

/** Function to setting an attribute in an SVGimage or component
 *@pre
    SVGimage object exists, is valid, and and is not NULL.
    newAttribute is not NULL
 *@post The appropriate attribute was set corectly
 *@return N/A
 *@param
    image - a pointer to an SVGimage struct
    elemType - enum value indicating elemtn to modify
    elemIndex - index of thje lement to modify
    newAttribute - struct containing name and value of the updated attribute
 **/
void setAttribute(SVGimage * image, elementType elemType, int elemIndex, Attribute * newAttribute)
{
    if(image == NULL || newAttribute == NULL)
    {
        return;
    }

    switch(elemType)
    {
        case 0:
            updateOtherAttr(image->otherAttributes, newAttribute);
            break;

        case 1:
            updateCircle(image->circles, elemIndex, newAttribute);
            break;

        case 2:
            updateRect(image->rectangles, elemIndex, newAttribute);
            break;

        case 3:
            updatePath(image->paths, elemIndex, newAttribute);
            break;

        case 4:
            updateGroup(image->groups, elemIndex, newAttribute);
            break;

        default:
            break;
    }

}

/** This function updates an attribute in a group
 *@param groups - A list of groups
 *@param index - index of the group to update in the list of groups
 *@param newAttribute - the new attribiute to add to the group
**/
void updateGroup(List * groups, int index, Attribute * newAttribute)
{
    Group * group;

    if(groups == NULL || newAttribute == NULL)
    {
        return;
    }

    group = (Group *) getItemAtIndex(groups, index);

    if(group == NULL)
    {
        deleteAttribute(newAttribute);
        return;
    }

    updateOtherAttr(group->otherAttributes, newAttribute);
}

/** This function updates an attribute in a path
 *@param paths - A list of paths
 *@param index - index of the path to update in the list of paths
 *@param newAttribute - the new attribiute to add to the path
**/
void updatePath(List * paths, int index, Attribute * newAttribute)
{
    Path * path;

    if(paths == NULL || newAttribute == NULL)
    {
        return;
    }

    path = (Path *) getItemAtIndex(paths, index);

    if(path == NULL)
    {
        deleteAttribute(newAttribute);
        return;
    }

    if(strcmp(newAttribute->name, "d") == 0)
    {
        char * newVal = malloc(sizeof(char) * strlen(newAttribute->value) + 1);
        strcpy(newVal, newAttribute->value);

        free(path->data);
        path->data = newVal;
        
        deleteAttribute(newAttribute);
    }
    else
    {
        updateOtherAttr(path->otherAttributes, newAttribute);
    }
}

/** This function updates an attribute in a rectangle
 *@param rects - A list of rectangles
 *@param index - index of the rectangle to update in the list of rectangles
 *@param newAttribute - the new attribiute to add to the rectangle
**/
void updateRect(List * rects, int index, Attribute * newAttribute)
{
    Rectangle * rect;

    if(rects == NULL || newAttribute == NULL)
    {
        return;
    }

    rect = (Rectangle *) getItemAtIndex(rects, index);

    if(rect == NULL)
    {
        deleteAttribute(newAttribute);
        return;
    }

    if(strcmp(newAttribute->name, "x") == 0)
    {
        rect->x = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else if(strcmp(newAttribute->name, "y") == 0)
    {
        rect->y = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else if(strcmp(newAttribute->name, "width") == 0)
    {
        rect->width = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else if(strcmp(newAttribute->name, "height") == 0)
    {
        rect->height = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else
    {
        updateOtherAttr(rect->otherAttributes, newAttribute);
    }
}

/** This function updates an attribute in a circle
 *@param circle - A list of circles
 *@param index - index of the circle to update in the list of circles
 *@param newAttribute - the new attribiute to add to the circle
**/
void updateCircle(List * circles, int index, Attribute * newAttribute)
{
    Circle * circ;

    if(circles == NULL || newAttribute == NULL)
    {
        return;
    }

    circ = (Circle *) getItemAtIndex(circles, index);

    if(circ == NULL)
    {
        deleteAttribute(newAttribute);
        return;
    }

    if(strcmp(newAttribute->name, "cx") == 0)
    {
        circ->cx = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else if(strcmp(newAttribute->name, "cy") == 0)
    {
        circ->cy = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else if(strcmp(newAttribute->name, "r") == 0)
    {
        circ->r = atof((char *)newAttribute->value);
        deleteAttribute(newAttribute);
    }
    else
    {
        updateOtherAttr(circ->otherAttributes, newAttribute);
    }
}

/** This function updates an attribute in a list of attributes
 *@param attributes - A list of attributes
 *@param newAttribute - the new attribiute to add/update in the group
**/
void updateOtherAttr(List * attributes, Attribute * newAttribute)
{
    Attribute * attr;

    if(attributes == NULL || newAttribute == NULL)
    {
        return;
    }

    attr = (Attribute *) findElement(attributes, compareAttributesBool, newAttribute);

    if(attr == NULL)
    {
        insertBack(attributes, newAttribute);
    }
    else
    {
        char * newVal = malloc(sizeof(char) * strlen(newAttribute->value) + 1);
        strcpy(newVal, newAttribute->value);

        free(attr->value);
        attr->value = newVal;
        
        deleteAttribute(newAttribute);
    }

}

/** This function gets an item at a specific index from a list
 *@return A void pointer to the item at the specified index in the list
 *@param list - list to get the data from
 *@param index - index of the data in the list
**/
void * getItemAtIndex(List * list, int index)
{
    Node * node;
    int i;

    if(list == NULL || index < 0 || index > list->length)
    {
        return NULL;
    }

    if(list->head != NULL)
    {
        node = list->head;
    }

    for(i = 0; i < index; i++)
    {
        if(node->next != NULL)
        {
            node = node->next;
        }
        else
        {
            return NULL;
        }
    }

    return node->data;

}

/** Function to adding an element - Circle, Rectngle, or Path - to an SVGimage
 *@pre
    SVGimage object exists, is valid, and and is not NULL.
    newElement is not NULL
 *@post The appropriate element was added correctly
 *@return N/A
 *@param
    image - a pointer to an SVGimage struct
    elemType - enum value indicating elemtn to modify
    newElement - pointer to the element sgtruct (Circle, Rectngle, or Path)
 **/
void addComponent(SVGimage * image, elementType type, void * newElement)
{
    if(image == NULL || newElement == NULL || type < 1 || type > 3)
    {
        return;
    }

    if(type == 1)
    {
        insertBack(image->circles, newElement);
    }
    else if (type == 2)
    {
        insertBack(image->rectangles, newElement);
    }
    else if (type == 3)
    {
        insertBack(image->paths, newElement);
    }
    
}

/** Function to converting an Attribute into a JSON string
*@pre Attribute is not NULL
*@post Attribute has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to an Attribute struct
**/
char * attrToJSON(const Attribute *a)
{
    int len;
    char * JSONstring;

    if(a == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    if(a->name == NULL || a->value == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    len = 23;
    len += strlen(a->name);
    len += strlen(a->value);

    JSONstring = malloc(sizeof(char) * len);
    sprintf(JSONstring, "{\"name\":\"%s\",\"value\":\"%s\"}", a->name, a->value);

    return JSONstring;
}

/** Function to converting a Circle into a JSON string
*@pre Circle is not NULL
*@post Circle has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Circle struct
**/
char * circleToJSON(const Circle *c)
{
    int len;
    char * JSONstring;

    if(c == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    if(c->otherAttributes == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    len = 41;
    len += numDigits(c->cx) + 3;
    len += numDigits(c->cy) + 3;
    len += numDigits(c->r) + 3;
    len += numDigits(c->otherAttributes->length);
    len += strlen(c->units);

    JSONstring = malloc(sizeof(char) * len);
    sprintf(JSONstring, "{\"cx\":%.2f,\"cy\":%.2f,\"r\":%.2f,\"numAttr\":%d,\"units\":\"%s\"}", c->cx, c->cy, c->r, c->otherAttributes->length, c->units);

    return JSONstring;
}

/** Function to converting a Rectangle into a JSON string
*@pre Rectangle is not NULL
*@post Rectangle has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Rectangle struct
**/
char * rectToJSON(const Rectangle *r)
{
    int len;
    char * JSONstring;

    if(r == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    if(r->otherAttributes == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    len = 44;
    len += numDigits(r->x) + 3;
    len += numDigits(r->y) + 3;
    len += numDigits(r->width) + 3;
    len += numDigits(r->height) + 3;
    len += numDigits(r->otherAttributes->length);
    len += strlen(r->units);

    JSONstring = malloc(sizeof(char) * len);
    sprintf(JSONstring,"{\"x\":%.2f,\"y\":%.2f,\"w\":%.2f,\"h\":%.2f,\"numAttr\":%d,\"units\":\"%s\"}", r->x, r->y, r->width, r->height, r->otherAttributes->length, r->units);

    return JSONstring;
}

/** Function to converting a Path into a JSON string
*@pre Path is not NULL
*@post Path has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Path struct
**/
char* pathToJSON(const Path *p)
{
    int len;
    char * JSONstring;
    char path[65];

    if(p == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    if(p->otherAttributes == NULL || p->data == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    len = 20;

    if(strlen(p->data) > 64)
    {
        len += 64;
    }
    else
    {
        len += strlen(p->data);
    }    

    len += numDigits(p->otherAttributes->length);
    strncpy(path, p->data, 64);
    
    if(strlen(p->data) > 64)
    {
        path[64] = '\0';
    }
    else
    {
        path[strlen(p->data)] = '\0';
    }

    JSONstring = malloc(sizeof(char) * len);
    sprintf(JSONstring,"{\"d\":\"%s\",\"numAttr\":%d}", path, p->otherAttributes->length);

    return JSONstring;
}

/** Function to converting a Group into a JSON string
*@pre Group is not NULL
*@post Group has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a Group struct
**/
char* groupToJSON(const Group *g)
{
    int len;
    int numChildren;
    char * JSONstring;

    if(g == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    if(g->otherAttributes == NULL || g->rectangles == NULL || g->circles == NULL || g->paths == NULL || g->groups == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    numChildren = g->rectangles->length + g->circles->length + g->paths->length + g->groups->length;

    len = 25;
    len += numDigits(numChildren);
    len += numDigits(g->otherAttributes->length);

    JSONstring = malloc(sizeof(char) * len);
    sprintf(JSONstring,"{\"children\":%d,\"numAttr\":%d}", numChildren, g->otherAttributes->length);

    return JSONstring;
}

/** Function to converting a list of Attribute structs into a JSON string
*@pre Attribute list is not NULL
*@post Attribute list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* attrListToJSON(const List *list)
{
    int len;
    Node * node;
    char * JSONstring;

    if(list == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    if(list->length == 0)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    /* Calculating string len */
    len = list->length + 2;

    node = list->head;
    
    while(node != NULL)
    {
        char * currString;

        currString = attrToJSON((Attribute *)(node->data));
        len += strlen(currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    JSONstring = malloc(sizeof(char) * len);

    /* Creating string */
    node = list->head;
    strcpy(JSONstring, "[");
    
    while(node != NULL)
    {
        char * currString;

        currString = attrToJSON((Attribute *)(node->data));
        strcat(JSONstring, currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {

            strcat(JSONstring, ",");
            node = node->next;
        }
        
    }

    strcat(JSONstring, "]");

    return JSONstring;
}

/** Function to converting a list of Circle structs into a JSON string
*@pre Circle list is not NULL
*@post Circle list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* circListToJSON(const List *list)
{
    int len;
    Node * node;
    char * JSONstring;

    if(list == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    if(list->length == 0)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    /* Calculating string len */
    len = list->length + 2;

    node = list->head;
    
    while(node != NULL)
    {
        char * currString;

        currString = circleToJSON((Circle *)(node->data));
        len += strlen(currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    JSONstring = malloc(sizeof(char) * len);

    /* Creating string */
    node = list->head;
    strcpy(JSONstring, "[");
    
    while(node != NULL)
    {
        char * currString;

        currString = circleToJSON((Circle *)(node->data));
        strcat(JSONstring, currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {

            strcat(JSONstring, ",");
            node = node->next;
        }
        
    }

    strcat(JSONstring, "]");

    return JSONstring;
}

/** Function to converting a list of Rectangle structs into a JSON string
*@pre Rectangle list is not NULL
*@post Rectangle list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* rectListToJSON(const List *list)
{
            int len;
    Node * node;
    char * JSONstring;

    if(list == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    if(list->length == 0)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    /* Calculating string len */
    len = list->length + 2;

    node = list->head;
    
    while(node != NULL)
    {
        char * currString;

        currString = rectToJSON((Rectangle *)(node->data));
        len += strlen(currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    JSONstring = malloc(sizeof(char) * len);

    /* Creating string */
    node = list->head;
    strcpy(JSONstring, "[");
    
    while(node != NULL)
    {
        char * currString;

        currString = rectToJSON((Rectangle *)(node->data));
        strcat(JSONstring, currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {

            strcat(JSONstring, ",");
            node = node->next;
        }
        
    }

    strcat(JSONstring, "]");

    return JSONstring;
}

/** Function to converting a list of Path structs into a JSON string
*@pre Path list is not NULL
*@post Path list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* pathListToJSON(const List *list)
{
            int len;
    Node * node;
    char * JSONstring;

    if(list == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    if(list->length == 0)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    /* Calculating string len */
    len = list->length + 2;

    node = list->head;
    
    while(node != NULL)
    {
        char * currString;

        currString = pathToJSON((Path *)(node->data));
        len += strlen(currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    JSONstring = malloc(sizeof(char) * len);

    /* Creating string */
    node = list->head;
    strcpy(JSONstring, "[");
    
    while(node != NULL)
    {
        char * currString;

        currString = pathToJSON((Path *)(node->data));
        strcat(JSONstring, currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {

            strcat(JSONstring, ",");
            node = node->next;
        }
        
    }

    strcat(JSONstring, "]");

    return JSONstring;
}

/** Function to converting a list of Group structs into a JSON string
*@pre Group list is not NULL
*@post Group list has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to a List struct
**/
char* groupListToJSON(const List *list)
{
            int len;
    Node * node;
    char * JSONstring;

    if(list == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    if(list->length == 0)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "[]");
        return JSONstring;
    }

    /* Calculating string len */
    len = list->length + 2;

    node = list->head;
    
    while(node != NULL)
    {
        char * currString;

        currString = groupToJSON((Group *)(node->data));
        len += strlen(currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    JSONstring = malloc(sizeof(char) * len);

    /* Creating string */
    node = list->head;
    strcpy(JSONstring, "[");
    
    while(node != NULL)
    {
        char * currString;

        currString = groupToJSON((Group *)(node->data));
        strcat(JSONstring, currString);
        free(currString);

        if(node->next == NULL)
        {
            break;
        }
        else
        {

            strcat(JSONstring, ",");
            node = node->next;
        }
        
    }

    strcat(JSONstring, "]");

    return JSONstring;
}

/** Function to converting an SVGimage into a JSON string
*@pre SVGimage is not NULL
*@post SVGimage has not been modified in any way
*@return A string in JSON format
*@param event - a pointer to an SVGimage struct
**/
char* SVGtoJSON(const SVGimage* imge)
{
    int len;
    char * JSONstring;

    if(imge == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    if(imge->rectangles == NULL || imge->circles == NULL || imge->paths == NULL || imge->groups == NULL)
    {
        JSONstring = malloc(sizeof(char) * 3);
        strcpy(JSONstring, "{}");
        return JSONstring;
    }

    List * rects = getRects((SVGimage *) imge);
    List * circs = getCircles((SVGimage *) imge);
    List * paths = getPaths((SVGimage *) imge);
    List * groups = getGroups((SVGimage *) imge);

    len = 49;
    len += numDigits(rects->length);
    len += numDigits(circs->length);
    len += numDigits(paths->length);
    len += numDigits(groups->length);

    JSONstring = malloc(sizeof(char) * len);
    sprintf(JSONstring,"{\"numRect\":%d,\"numCirc\":%d,\"numPaths\":%d,\"numGroups\":%d}", rects->length, circs->length, paths->length, groups->length);

    freeList(rects);
    freeList(circs);
    freeList(paths);
    freeList(groups);

    return JSONstring;
}

/** This function counts the number of digits in an int
 *@return The number of digits in the int passed
 *@param num - The int for which the number of digits need to be counted
**/
int numDigits(int num)
{
    if(num == 0)
    {
        return 1;
    }

    int digits = floor(log10(abs(num))) + 1;

    return digits;
}

/* ******************************* Bonus A2 functions - optional for A2 *************************** */

/** Function to converting a JSON string into an SVGimage struct
*@pre JSON string is not NULL
*@post String has not been modified in any way
*@return A newly allocated and initialized SVGimage struct
*@param str - a pointer to a string
**/
SVGimage * JSONtoSVG(const char* svgString)
{
    SVGimage * img;
    char * title;
    char * desc;
    
    if(svgString == NULL)
    {
        return NULL;
    }

    img = malloc(sizeof(SVGimage));

    title = getValueFromJSONstring("\"title\"", svgString);
    desc = getValueFromJSONstring("\"descr\"", svgString);

    /* Setting the name space */
    strcpy(img->namespace, "http://www.w3.org/2000/svg");

    /* Setting the title */
    if(title != NULL)
    {
        strncpy(img->title, title, 255);
        free(title);
    }
    else
    {
        strcpy(img->title, "empty");
    }

    /* Setting the description */
    if(desc != NULL)
    {
        strncpy(img->description, desc, 255);
        free(desc);
    }
    else
    {
        strcpy(img->description, "empty");
    }

    /* Intialising all the lists */
    img->rectangles = initializeList(rectangleToString, deleteRectangle, compareRectangles);
    img->circles = initializeList(circleToString, deleteCircle, compareCircles);
    img->paths = initializeList(pathToString, deletePath, comparePaths);
    img->groups = initializeList(groupToString, deleteGroup, compareGroups);
    img->otherAttributes = initializeList(attributeToString, deleteAttribute, compareAttributes);

    return img;
}

/** Function to converting a JSON string into a Rectangle struct
*@pre JSON string is not NULL
*@post Rectangle has not been modified in any way
*@return A newly allocated and initialized Rectangle struct
*@param str - a pointer to a string
**/
Rectangle * JSONtoRect(const char* svgString)
{
    Rectangle * rect;
    char * x;
    char * y;
    char * width;
    char * height;
    char * units;
    
    if(svgString == NULL)
    {
        return NULL;
    }

    rect = malloc(sizeof(Rectangle));

    /* Getting all the attribute values from the string */
    x = getValueFromJSONstring("\"x\"", svgString);
    y = getValueFromJSONstring("\"y\"", svgString);
    width = getValueFromJSONstring("\"w\"", svgString);
    height = getValueFromJSONstring("\"h\"", svgString);
    units = getValueFromJSONstring("\"units\"", svgString);

    /* checking if any of the values is NULL */
    if(x == NULL || y == NULL || width == NULL || height == NULL)
    {
        free(x);
        free(y);
        free(width);
        free(height);
        free(units);
        free(rect);

        return NULL;
    }

    /* Setting values */
    rect->x = atof(x);
    rect->y = atof(y);
    rect->width = atof(width);
    rect->height = atof(height);
    
    if(units != NULL)
    {
        strncpy(rect->units, units, 49);
    }
    else
    {
        rect->units[0] = 0;
    }

    /* Intialising other attributes list */
    rect->otherAttributes = initializeList(attributeToString, deleteAttribute, compareAttributes);

    /* Freeing all the strings */
    free(x);
    free(y);
    free(width);
    free(height);
    free(units);

    return rect;
}

/** Function to converting a JSON string into a Circle struct
*@pre JSON string is not NULL
*@post Circle has not been modified in any way
*@return A newly allocated and initialized Circle struct
*@param str - a pointer to a string
**/
Circle * JSONtoCircle(const char* svgString)
{
    Circle * circ;
    char * cx;
    char * cy;
    char * r;
    char * units;
    
    if(svgString == NULL)
    {
        return NULL;
    }

    circ = malloc(sizeof(Circle));

    /* Getting all the attribute values from the string */
    cx = getValueFromJSONstring("\"cx\"", svgString);
    cy = getValueFromJSONstring("\"cy\"", svgString);
    r = getValueFromJSONstring("\"r\"", svgString);
    units = getValueFromJSONstring("\"units\"", svgString);

    /* checking if any of the values is NULL */
    if(cx == NULL || cy == NULL || r == NULL)
    {
        free(cx);
        free(cy);
        free(r);
        free(units);
        free(circ);

        return NULL;
    }

    /* Setting values */
    circ->cx = atof(cx);
    circ->cy = atof(cy);
    circ->r = atof(r);

    if(units != NULL)
    {
        strncpy(circ->units, units, 49);
    }
    else
    {
        circ->units[0] = 0;
    }
    

    /* Intialising other attributes list */
    circ->otherAttributes = initializeList(attributeToString, deleteAttribute, compareAttributes);

    /* Freeing all the strings */
    free(cx);
    free(cy);
    free(r);
    free(units);

    return circ;
}

/** Function to get property value from a JSON string 
*@pre JSONstring & name is not NULL
*@post JSONstring has not been modified in any way
*@return A char pointer to the value of the property
*@param name - a pointer to a string which holds the name of the property
*@param JSONstring - a pointer to a string which holds the JSON string
**/
char * getValueFromJSONstring(char * name, const char * JSONstring)
{
    char * value;
    char * attrValue;
    int i;

    if(name == NULL || JSONstring == NULL)
    {
        return NULL;
    }

    /* Finding the attribute in the string */
    value = strstr(JSONstring, name);

    if(value == NULL)
    {
        return NULL;
    }

    /* Skipping the attribute name to get to the value */
    for(i = 0; i < strlen(value); i++)
    {
        if(value[i] == ':')
        {
            i++;
            break;
        }
        else if(value[i] == '\0' || value[i] == '}')
        {
            return NULL;
        }
    }

    value += i;

    if(*value == '"')
    {
        value++;
        if(*value == '"' || *value == ',')
        {
            return NULL;
        }
    }

    /* getting the value and copying it on to a new string */
    for(i = 0; i < strlen(value); i++)
    {
        if(value[i] == '"' || value[i] == ',')
        {
            break;
        }
        else if(value[i] == '\0' || value[i] == '}')
        {
            return NULL;
        }
    }

    if(i == 0)
    {
        return NULL;
    }

    attrValue = malloc(sizeof(char) * (i+1));
    strncpy(attrValue, value, i);
    attrValue[i] = '\0';

    return attrValue;
}

/** Function to open a file and converting the contents to JSON
*@pre fileName is not NULL
*@return A char pointer to the JSON string
*@param fileName - a pointer to the file name
*@param JSONstring - a pointer to a string which holds the JSON string
**/
char * getFileJSON(char * fileName)
{
    SVGimage * img;
    char * filePath;
    char * JSONstr;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return NULL;
    }

    JSONstr = SVGtoJSON(img);

    deleteSVGimage(img);
    free(filePath);

    return JSONstr;
}

char * imgToJSONDetails(char * fileName)
{
    SVGimage * img;
    char * filePath;
    char * JSONstr;
    char * rectList;
    char * circList;
    char * pathList;
    char * groupList;
    int stringLen, fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return NULL;
    }

    rectList = rectListToJSON(img->rectangles);
    circList = circListToJSON(img->circles);
    pathList = pathListToJSON(img->paths);
    groupList = groupListToJSON(img->groups);

    stringLen = 60;
    stringLen += strlen(rectList);
    stringLen += strlen(circList);
    stringLen += strlen(pathList);
    stringLen += strlen(groupList);
    stringLen += strlen(img->title);
    stringLen += strlen(img->description);

    JSONstr = malloc(sizeof(char) * stringLen);

    sprintf(JSONstr, "{\"title\":\"%s\",\"desc\":\"%s\",\"rects\":%s,\"circs\":%s,\"paths\":%s,\"groups\":%s}",img->title, img->description, rectList, circList, pathList, groupList);

    free(filePath);
    free(rectList);
    free(circList);
    free(pathList);
    free(groupList);
    deleteSVGimage(img);

    return JSONstr;
}

char * getRectAttr(char * fileName, int index)
{
    SVGimage * img;
    char * filePath;
    char * JSONstr;
    Rectangle * currRect;
    Node * currNode;
    int fileNameLen, i;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return NULL;
    }

    currNode = img->rectangles->head;

    for(i = 0; i < index; i++)
    {
        currNode = currNode->next;
    }

    currRect = (Rectangle *)currNode->data;

    JSONstr = attrListToJSON(currRect->otherAttributes);

    free(filePath);
    deleteSVGimage(img);

    return JSONstr;
}

char * getCircAttr(char * fileName, int index)
{
    SVGimage * img;
    char * filePath;
    char * JSONstr;
    Circle * currCirc;
    Node * currNode;
    int fileNameLen, i;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return NULL;
    }

    currNode = img->circles->head;

    for(i = 0; i < index; i++)
    {
        currNode = currNode->next;
    }

    currCirc = (Circle *)currNode->data;

    JSONstr = attrListToJSON(currCirc->otherAttributes);

    free(filePath);
    deleteSVGimage(img);

    return JSONstr;
}

char * getPathAttr(char * fileName, int index)
{
    SVGimage * img;
    char * filePath;
    char * JSONstr;
    Path * currPath;
    Node * currNode;
    int fileNameLen, i;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return NULL;
    }

    currNode = img->paths->head;

    for(i = 0; i < index; i++)
    {
        currNode = currNode->next;
    }

    currPath = (Path *)currNode->data;

    JSONstr = attrListToJSON(currPath->otherAttributes);

    free(filePath);
    deleteSVGimage(img);

    return JSONstr;
}

char * getGroupAttr(char * fileName, int index)
{
    SVGimage * img;
    char * filePath;
    char * JSONstr;
    Group * currGroup;
    Node * currNode;
    int fileNameLen, i;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return NULL;
    }

    currNode = img->groups->head;

    for(i = 0; i < index; i++)
    {
        currNode = currNode->next;
    }

    currGroup = (Group *)currNode->data;

    JSONstr = attrListToJSON(currGroup->otherAttributes);

    free(filePath);
    deleteSVGimage(img);

    return JSONstr;
}

bool updateRectAttr(char * fileName, int index, char * attrName, char * attrVal)
{
    SVGimage * img;
    char * filePath;
    Attribute * newAttr;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    newAttr = malloc(sizeof(Attribute));
    newAttr->name = malloc(sizeof(char) * (strlen(attrName) + 1));
    newAttr->value = malloc(sizeof(char) * (strlen(attrVal) + 1));

    strcpy(newAttr->name, attrName);
    strcpy(newAttr->value, attrVal);

    updateRect(img->rectangles, index, newAttr);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool updateCircAttr(char * fileName, int index, char * attrName, char * attrVal)
{
    SVGimage * img;
    char * filePath;
    Attribute * newAttr;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    newAttr = malloc(sizeof(Attribute));
    newAttr->name = malloc(sizeof(char) * (strlen(attrName) + 1));
    newAttr->value = malloc(sizeof(char) * (strlen(attrVal) + 1));

    strcpy(newAttr->name, attrName);
    strcpy(newAttr->value, attrVal);

    updateCircle(img->circles, index, newAttr);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool updatePathAttr(char * fileName, int index, char * attrName, char * attrVal)
{
    SVGimage * img;
    char * filePath;
    Attribute * newAttr;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    newAttr = malloc(sizeof(Attribute));
    newAttr->name = malloc(sizeof(char) * (strlen(attrName) + 1));
    newAttr->value = malloc(sizeof(char) * (strlen(attrVal) + 1));

    strcpy(newAttr->name, attrName);
    strcpy(newAttr->value, attrVal);

    updatePath(img->paths, index, newAttr);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool updateGroupAttr(char * fileName, int index, char * attrName, char * attrVal)
{
    SVGimage * img;
    char * filePath;
    Attribute * newAttr;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    newAttr = malloc(sizeof(Attribute));
    newAttr->name = malloc(sizeof(char) * (strlen(attrName) + 1));
    newAttr->value = malloc(sizeof(char) * (strlen(attrVal) + 1));

    strcpy(newAttr->name, attrName);
    strcpy(newAttr->value, attrVal);

    updateGroup(img->groups, index, newAttr);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool updateImgAttr(char * fileName, char * attrName, char * attrVal)
{
    SVGimage * img;
    char * filePath;
    Attribute * newAttr;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    newAttr = malloc(sizeof(Attribute));
    newAttr->name = malloc(sizeof(char) * (strlen(attrName) + 1));
    newAttr->value = malloc(sizeof(char) * (strlen(attrVal) + 1));

    strcpy(newAttr->name, attrName);
    strcpy(newAttr->value, attrVal);

    updateOtherAttr(img->otherAttributes, newAttr);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool updateImgTitle(char * fileName, char * title)
{
    SVGimage * img;
    char * filePath;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    strncpy(img->title, title, 255);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool updateImgDesc(char * fileName, char * title)
{
    SVGimage * img;
    char * filePath;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    strncpy(img->description, title, 255);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool addJSONRectToImg(char * fileName, char * JSONstring)
{
    SVGimage * img;
    char * filePath;
    Rectangle * currRect;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    currRect = JSONtoRect(JSONstring);

    addComponent(img, 2, currRect);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool addJSONCircToImg(char * fileName, char * JSONstring)
{
    SVGimage * img;
    char * filePath;
    Circle * currCirc;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    currCirc = JSONtoCircle(JSONstring);

    addComponent(img, 1, currCirc);

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool scaleRects(char * fileName, int factor)
{
    SVGimage * img;
    char * filePath;
    Node * node;
    Rectangle * currRect;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    node = img->rectangles->head;
    
    while(node != NULL)
    {
        currRect = (Rectangle *)node->data;

        currRect->width *= factor;
        currRect->height *= factor;

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool scaleCircs(char * fileName, int factor)
{
    SVGimage * img;
    char * filePath;
    Node * node;
    Circle * currCirc;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = createValidSVGimage(filePath, "./parser/include/svg.xsd");

    if(img == NULL)
    {
        return false;
    }

    node = img->circles->head;
    
    while(node != NULL)
    {
        currCirc = (Circle *)node->data;

        currCirc->r *= factor;

        if(node->next == NULL)
        {
            break;
        }
        else
        {
            node = node->next;
        }
        
    }

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}

bool createImg(char * fileName)
{
    SVGimage * img;
    char * filePath;
    Rectangle * rect;
    int fileNameLen;

    fileNameLen = strlen(fileName);
    filePath = malloc(sizeof(char) + (fileNameLen + 11));
    sprintf(filePath, "./uploads/%s", fileName);

    img = JSONtoSVG("{\"title\":\"\",\"descr\":\"\"}");

    if(img == NULL)
    {
        return false;
    }

    if(!validateSVGimage(img, "./parser/include/svg.xsd"))
    {
        free(filePath);
        deleteSVGimage(img);
        return false;
    }

    rect = malloc(sizeof(Rectangle));
    rect->x = 2;
    rect->y = 2;
    rect->height = 1;
    rect->width = 1;
    strcpy(rect->units, "cm");

    addComponent(img, 2, rect);

    writeSVGimage(img, filePath);

    free(filePath);
    deleteSVGimage(img);

    return true;
}
